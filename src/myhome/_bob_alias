# .bob_alias

# ///////////////////////////////////////////////////////////////////////////
# ////  VANILLA ALIASES
# ///////////////////////////////////////////////////////////////////////////
alias      ..="cdvoodoo .."
alias     ...="cdvoodoo ../.."
alias    apps='ps axxx | grep appserver_cm[1-9] | awk "/\/bin\/sh/ {split(\$7,fld,/_/); print fld[1]}" | sort | uniq'
alias     cls="clear"
alias      gv="/usr/local/bin/gvim"
alias       h="history"
alias       j="jobs"
alias      l.="ls -d .*"
alias      me="cdvoodoo ~/proj/robraft"
alias    proj="cdvoodoo ~/proj"
alias    srvs='ps axxx | grep appserver_cm[1-9] | awk "/\/bin\/sh/ {print \$7}" | sort | uniq'

alias      st="/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl"
alias     sub="/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl"
alias    subl="/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl"

# ///////////////////////////////////////////////////////////////////////////
# ////  CONDITIONAL ALIASES
# ///////////////////////////////////////////////////////////////////////////
[[ -d /mnt/c ]] && alias outlook="cmd /c start '' 'C:\Program Files (x86)/Microsoft Office\Office14\OUTLOOK.EXE'"
[[ -d /opt/norkom/fca ]] && alias fca="cd /opt/norkom/fca"
[[ -f ~/.ssh/proxyon ]]  && alias proxyon="echo please use proxyon2"
[[ -f ~/.ssh/proxyon2 ]]  && alias proxyon2=". ~/.ssh/proxyon2"
[[ -f ~/.ssh/proxyoff ]] && alias proxyoff=". ~/.ssh/proxyoff"
[[ -f /usr/bin/mc ]]     && alias mc='/usr/bin/mc -P ~/.mc.dir  "$PWD" ~ && export MCDIR_="$(< ~/.mc.dir )" && cd "$MCDIR_" && rm ~/.mc.dir > /dev/null'
[[ -f /usr/share/mc/bin/mc-wrapper.sh ]] && alias mc='. /usr/share/mc/bin/mc-wrapper.sh -a'

# ///////////////////////////////////////////////////////////////////////////
# ////  PROBE LS CMD TO DETERMINE ACCEPTABLE PARMS
# ///////////////////////////////////////////////////////////////////////////
ls --color=auto >/dev/null 2>&1    && LS_COLOR_PARM_="--color=auto"
ls --color=auto >/dev/null  2>&1   || LS_COLOR_PARM_="-G"
ls $LS_COLOR_PARM_ >/dev/null 2>&1 || LS_COLOR_PARM_=
ls --group-directories-first >/dev/null 2>&1 && LSGRPDIR_PARM_="--group-directories-first"
ls --group-directories-first >/dev/null 2>&1 || LSGRPDIR_PARM_=" "

alias       ls="ls -F $LS_COLOR_PARM_ $LSGRPDIR_PARM_"
alias       ll="ls -lF $LS_COLOR_PARM_ $LSGRPDIR_PARM_"
alias       lo="ls -oF $LS_COLOR_PARM_ $LSGRPDIR_PARM_"

# ///////////////////////////////////////////////////////////////////////////
# ////  PROBE CHMOD CMD TO DETERMINE IF VERBOSE IS AN ACCEPTABLE PARM
# ///////////////////////////////////////////////////////////////////////////
VERBOSE_=
VERBOSERM_=
touch scratch.scratch
chmod -v 777 scratch.scratch > /dev/null 2>&1 && VERBOSE_=-v
rm -e scratch.scratch > /dev/null 2>&1 && VERBOSERM_=-e
rm scratch.scratch > /dev/null 2>&1
alias chgrp="chgrp $VERBOSE_"
alias chmod="chmod $VERBOSE_"
alias    cp="cp $VERBOSE_"
alias    mv="mv $VERBOSE_"
alias    rm="rm $VERBOSE_ $VERBOSERM_"


# ///////////////////////////////////////////////////////////////////////////
#  based on https://gist.github.com/skizzybiz/3789296
#    and then liberally "bobified" to suit my sense of neatness & aesthetics
# ///////////////////////////////////////////////////////////////////////////
# Define colors
RESET='\[\033[00m\]'

BKFG='\[\033[0;30m\]'    # black   foreground
RDFG='\[\033[0;31m\]'    # red     foreground
GNFG='\[\033[0;32m\]'    # green   foreground
YLFG='\[\033[0;33m\]'    # yellow  foreground
BLFG='\[\033[0;34m\]'    # blue    foreground
MGFG='\[\033[0;35m\]'    # magenta foreground
CYFG='\[\033[0;36m\]'    # cyan    foreground
GRFG='\[\033[0;37m\]'    # gray    foreground

BKFGUL='\[\033[4;30m\]'  # black   foreground, underline
RDFGUL='\[\033[4;31m\]'  # red     foreground, underline
GNFGUL='\[\033[4;32m\]'  # green   foreground, underline
YLFGUL='\[\033[4;33m\]'  # yellow  foreground, underline
BLFGUL='\[\033[4;34m\]'  # blue    foreground, underline
MGFGUL='\[\033[4;35m\]'  # magenta foreground, underline
CYFGUL='\[\033[4;36m\]'  # cyan    foreground, underline
GRFGUL='\[\033[4;37m\]'  # gray    foreground, underline

BKFGBD='\[\033[1;30m\]'  # black   foreground, bright
RDFGBD='\[\033[1;31m\]'  # red     foreground, bright
GNFGBD='\[\033[1;32m\]'  # green   foreground, bright
YLFGBD='\[\033[1;33m\]'  # yellow  foreground, bright
BLFGBD='\[\033[1;34m\]'  # blue    foreground, bright
MGFGBD='\[\033[1;35m\]'  # magenta foreground, bright
CYFGBD='\[\033[1;36m\]'  # cyan    foreground, bright
GRFGBD='\[\033[1;37m\]'  # gray    foreground, bright

BKBG='\[\033[40m\]'      # black   background
RDBG='\[\033[41m\]'      # red     background
GNBG='\[\033[42m\]'      # green   background
YLBG='\[\033[43m\]'      # yellow  background
BLBG='\[\033[44m\]'      # blue    background
MGBG='\[\033[45m\]'      # magenta background
CYBG='\[\033[46m\]'      # cyan    background
GRBG='\[\033[47m\]'      # gray    background

# SYMBOLS
SYMBUG='⍾ '
SYMDELTA='▲'
SYMBRANCH='〒'
SYMALIEN='👽'

# Detect whether the current directory is a git repository.
function is_git_repository {
  git branch > /dev/null 2>&1
}

# Determine the branch/state information for this git repository.
function set_git_branch {
  # Capture the output of the "git status" command.
  git_status="$(git status 2> /dev/null)"

  # Set color based on clean/staged/dirty.
  if [[ ${git_status} =~ "working directory clean" ]]; then
    state=$GRFG
		cleandirty=""
  elif [[ ${git_status} =~ "Changes to be committed" ]]; then
    state=$GRUL
		cleandirty="$RDFG$SYMDELTA$RESET"
  else
    state=$GRUL
		cleandirty="$RDFG$SYMDELTA$RESET"
  fi

  # Set arrow icon based on status against remote.
  remote_pattern="# Your branch is (.*) of"
  if [[ ${git_status} =~ ${remote_pattern} ]]; then
    if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
      remote="↑"
    else
      remote="↓"
    fi
  else
    remote=""
  fi
  diverge_pattern="# Your branch and (.*) have diverged"
  if [[ ${git_status} =~ ${diverge_pattern} ]]; then
    remote="↕"
  fi
	remote="$RDFG$remote$RESET"

  # Get the name of the branch.
  branch_pattern="^On branch ([^${IFS}]*)"
  if [[ ${git_status} =~ ${branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
  fi

	if [[ "$branch" == "" ]] ; then
		branch="-none-"
	fi

  # Set the final branch string.
  BRANCH="${cleandirty}${remote} ${state}(git:${branch})$RESET"
}

# Return the prompt symbol to use, colorized based on the return value of the
# previous command.
function set_prompt_symbol () {
	## PROMPT_SYMBOL="⌘"
	PROMPT_SYMBOL="$"
  if test $1 -ne 0 ; then
    PROMPT_SYMBOL="$RDFG$PROMPT_SYMBOL$RESET"
  fi
}

# Set the full bash prompt.
function set_bash_prompt () {
  # echo "set_bash_prompt"
  # Set the PROMPT_SYMBOL variable. We do this first so we don't lose the
  # return value of the last command.
  set_prompt_symbol $?

  # Set the BRANCH variable.
	BRANCH=''
  if is_git_repository ; then
    set_git_branch
  fi

  # Fill spaces between the left and right halves
  strippedbranch=`echo $BRANCH | sed 's|\\\\\\[[^]]*\\]||g'`
  ## lefthalf="`whoami`@`hostname -s` `pwd | sed "s|$HOME|~|"` $strippedbranch"
  ## righthalf=`date '+%a %b %d %T'`
  lefthalf="`whoami`@`hostname -s` `pwd | sed "s|$HOME|~|"` `date '+%T'`"
  righthalf=$strippedbranch
  let fillsize=${COLUMNS}-${#lefthalf}-${#righthalf}-2
  fill=`printf ' %.0s' {1..300}` # 300 spaces
  fill=${fill:0:$fillsize}

  # Set the bash prompt variable.
  PS1="\n$CYFG\t $GNFG\u@\h$RESET:$YLFG\w $fill${BRANCH}\n\
$YLFG[$THIS_SHELL $THIS_VERSION] ${RESET}${PROMPT_SYMBOL} "
}

# Tell bash to execute this function just before displaying its prompt.
PROMPT_COMMAND=set_bash_prompt
# ///////////////////////////////////////////////////////////////////////////

# vim: set filetype=sh sws=2 sw=2 sts=2 ts=2 noexpandtab :
